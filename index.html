<!DOCTYPE html>
<html>
<head>
  <title>Remote Sensor Monitor</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }
    #loading {
      text-align: center;
      margin: 20px;
    }
    #error {
      color: red;
      margin: 20px;
    }
    #status {
      color: green;
      margin: 10px;
      font-style: italic;
    }
    canvas {
      max-height: 600px;
    }
    .controls {
      margin: 20px 0;
    }
    button {
      padding: 8px 15px;
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <h2>Remote Sensor Data from Google Sheets</h2>
  <div class="controls">
    <button id="refreshBtn">Refresh Now</button>
    <span id="status">Last updated: Never</span>
  </div>
  <div id="loading">Loading initial data...</div>
  <div id="error"></div>
  <canvas id="chart" height="400"></canvas>

  <script>
    // Configuration
    const MAX_DATA_POINTS = 100; // Limit number of points to maintain performance
    const REFRESH_INTERVAL = 5000; // 30 seconds
    
    const chartCtx = document.getElementById('chart').getContext('2d');
    const sensorChart = new Chart(chartCtx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { 
            label: 'Temperature (°C)', 
            data: [], 
            borderColor: 'rgba(255, 99, 132, 1)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            tension: 0.1,
            fill: false,
            yAxisID: 'y' 
          },
          { 
            label: 'Humidity (%)', 
            data: [], 
            borderColor: 'rgba(54, 162, 235, 1)',
            backgroundColor: 'rgba(54, 162, 235, 0.2)',
            tension: 0.1,
            fill: false,
            yAxisID: 'y1'
          }
        ]
      },
      options: {
        responsive: true,
        interaction: {
          mode: 'index',
          intersect: false,
        },
        animation: {
          duration: 500 // Smooth animation for updates
        },
        scales: {
          x: {
            ticks: {
              autoSkip: true,
              maxTicksLimit: 20,
              callback: function(value) {
                // Show only time portion for better readability
                const fullDate = this.getLabelForValue(value);
                return fullDate.split(' ')[1]; // Return only time
              }
            }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: {
              display: true,
              text: 'Temperature (°C)'
            },
            min: function(context) {
              // Auto-scale with 5% buffer
              const min = Math.min(...context.chart.data.datasets[0].data);
              return min - (min * 0.05);
            }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            title: {
              display: true,
              text: 'Humidity (%)'
            },
            grid: {
              drawOnChartArea: false,
            },
            min: 0,
            max: 100
          }
        }
      }
    });

    // Store the last timestamp we've seen to detect new data
    let lastTimestamp = null;
    let refreshIntervalId = null;

    async function fetchData() {
      try {
        const url = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vS6P6hzIdOoBMMRfgCgFF7gQ9DWvhlsmXz2hxHx3mmJuYIlanN8QjWWYT1V34UXd9PJC-2qWbTiBriZ/pub?gid=0&single=true&output=csv';
        
        // Add timestamp to URL to prevent caching
        const timestamp = new Date().getTime();
        const response = await fetch(`${url}&t=${timestamp}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const dataText = await response.text();
        const rows = dataText.split('\n').filter(row => row.trim() !== '');
        
        if (rows.length <= 1) {
          throw new Error('No data rows found in the sheet');
        }
        
        // Skip header row
        const dataRows = rows.slice(1); 
        
        const newTimes = [];
        const newTemps = [];
        const newHums = [];
        let newDataFound = false;

        // Process rows in reverse to get newest data first
        for (let i = dataRows.length - 1; i >= 0; i--) {
          const row = dataRows[i];
          const cols = parseCSVRow(row);
          
          if (cols.length >= 4) {
            try {
              const dateStr = cols[0].trim();
              const timeStr = cols[1].trim();
              const fullTimestamp = `${dateStr} ${timeStr}`;
              const temp = parseFloat(cols[2].trim());
              const hum = parseFloat(cols[3].trim());
              
              if (!isNaN(temp) && !isNaN(hum)) {
                // Check if this is new data
                if (!lastTimestamp || new Date(fullTimestamp) > new Date(lastTimestamp)) {
                  newDataFound = true;
                  lastTimestamp = fullTimestamp;
                }
                
                // Add to arrays (will be reversed later)
                newTimes.push(fullTimestamp);
                newTemps.push(temp);
                newHums.push(hum);
              }
            } catch (e) {
              console.error('Error parsing row:', row, e);
            }
          }
          
          // Stop if we have enough points
          if (newTimes.length >= MAX_DATA_POINTS) break;
        }

        // Reverse to maintain chronological order
        newTimes.reverse();
        newTemps.reverse();
        newHums.reverse();

        if (newTimes.length > 0) {
          document.getElementById('loading').style.display = 'none';
          document.getElementById('error').textContent = '';
          
          sensorChart.data.labels = newTimes;
          sensorChart.data.datasets[0].data = newTemps;
          sensorChart.data.datasets[1].data = newHums;
          sensorChart.update();
          
          // Update status
          const now = new Date();
          document.getElementById('status').textContent = 
            `Last updated: ${now.toLocaleTimeString()} | New data: ${newDataFound ? 'Yes' : 'No'}`;
        } else {
          document.getElementById('error').textContent = 'No valid data found in the sheet.';
        }
      } catch (error) {
        console.error('Error fetching data:', error);
        document.getElementById('error').textContent = `Error loading data: ${error.message}`;
        document.getElementById('loading').style.display = 'none';
      }
    }

    function parseCSVRow(row) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < row.length; i++) {
        const char = row[i];
        
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      
      result.push(current);
      return result;
    }

    // Manual refresh button
    document.getElementById('refreshBtn').addEventListener('click', fetchData);

    // Initial load
    fetchData();
    
    // Start auto-refresh
    refreshIntervalId = setInterval(fetchData, REFRESH_INTERVAL);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (refreshIntervalId) {
        clearInterval(refreshIntervalId);
      }
    });
  </script>
</body>
</html>